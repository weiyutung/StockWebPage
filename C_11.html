<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>è‚¡ç¥¨åˆ†æå¹³å°demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script>
      // æˆäº¤é‡å£“ç¸®æ¯”ä¾‹ï¼ˆå…¨åŸŸå¯èª¿æ•´ï¼‰ 0.3~0.6å»ºè­°ç¯„åœ
      let VOL_PAD_TOP_RATIO = 0.4;

      if (
        location.hash.includes("access_token") &&
        !location.pathname.endsWith("ResetPassword.html")
      ) {
        // é‡å°å‘åˆ°æ­£ç¢ºé é¢
        const target = "/StockWebPage/ResetPassword.html" + location.hash;
        location.replace(target);
      }
    </script>
    <script>
      window.addEventListener("load", () => {
        const hash = window.location.hash;
        if (hash.includes("access_token") && hash.includes("type=signup")) {
          alert(" é©—è­‰æˆåŠŸï¼æ‚¨å·²å®Œæˆè¨»å†Šï¼Œå¯ä»¥ç™»å…¥ç³»çµ±äº†ï¼");
        }
      });
    </script>
    <script>
      // å¦‚æœç¶²å€åŒ…å« access_tokenï¼Œä»£è¡¨å¾é©—è­‰ä¿¡å›ä¾†
      if (location.hash.includes("access_token")) {
        // å°å‘ StockWebPage/index.htmlï¼Œä¸¦ä¿ç•™ access_token ç­‰è³‡è¨Š
        const redirectTarget = "/StockWebPage/index.html" + location.hash;
        location.replace(redirectTarget);
      }
    </script>
    <style>
      body {
        display: flex;
        flex-direction: row;
        margin: 0;
        font-family: Arial, sans-serif;
      }
      #main-content {
        width: 75%;
        padding: 20px;
        box-sizing: border-box;
      }
      #right-panel {
        width: 25%;
        padding: 20px;
        background: #f9f9f9;
        border-left: 1px solid #ccc;
        box-sizing: border-box;
        overflow-y: auto;
      }
      .checkbox-group label {
        display: block;
        margin: 10px 0;
        font-size: 16px;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 20px;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: center;
      }
      th {
        background-color: #f2f2f2;
      }
      select,
      input[type="date"],
      input[type="text"],
      button {
        font-size: 16px;
        margin: 5px;
        padding: 5px;
      }
      #chart {
        max-width: 100%;
        margin-top: 50px;
      }

      /* æœå°‹æ¡†å®¹å™¨ç½®ä¸­ */
      .search-container {
        display: flex;
        flex-direction: column;
        align-items: center; /* æ°´å¹³ç½®ä¸­ */
        margin-top: 10px;
        margin-bottom: 20px;
        position: relative; /* ä¸‹æ‹‰åˆ—è¡¨çš„å®šä½åƒè€ƒ */
      }
      /* label ç¾åŒ– */
      .search-container label {
        font-size: 18px;
        margin-bottom: 10px;
      }

      #symbolInput {
        width: 300px;
        height: 40px;
        font-size: 18px;
        padding: 5px 10px;
        border-radius: 8px;
        border: 1px solid #ccc;
        z-index: 1;
        box-sizing: border-box; /* ç¢ºä¿ padding ä¸å½±éŸ¿å¯¬åº¦ */
      }

      #suggestions {
        display: none; /* é è¨­éš±è— */
        position: absolute;
        top: 100%; /* ç·Šè²¼è¼¸å…¥æ¡†ä¸‹æ–¹ */
        left: 50%; /* å…ˆç§»åˆ°å®¹å™¨ä¸­é–“ */
        transform: translateX(
          -50%
        ); /* å†å‘å·¦å¹³ç§» 50% å¯¬åº¦ï¼Œè®“å·¦å³å±…ä¸­å°é½Šè¼¸å…¥æ¡† */
        width: 300px; /* å’Œè¼¸å…¥æ¡†åŒå¯¬ */
        background: #fff;
        border: 1px solid #ccc;
        border-top: none;
        max-height: 200px;
        overflow-y: auto;
        z-index: 10;
        box-sizing: border-box;
      }

      /* æ™‚é–“åˆ—å®¹å™¨ */
      .time-range-bar {
        display: flex;
        gap: 12px;
        align-items: center;
        font-size: 15px;
        font-family: Arial, sans-serif;
      }

      /* å–®å€‹é¸é … */
      .time-range-item {
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
        transition: background 0.2s, color 0.2s;
      }

      /* é è¨­æ¨£å¼ */
      .time-range-item:hover {
        background-color: #f2f2f2;
      }

      /* é¸ä¸­ç‹€æ…‹ */
      .time-range-item.active {
        background-color: #f0f0f0;
        font-weight: bold;
      }

      /* æ—¥æ›†åœ–æ¡ˆæŒ‰éˆ• */
      .calendar-btn {
        cursor: pointer;
        padding: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: background 0.2s;
      }

      .calendar-btn:hover {
        background-color: #f2f2f2;
      }

      .calendar-btn svg {
        width: 18px;
        height: 18px;
        fill: #333;
      }

      /* è‡ªè¨‚æ™‚é–“å®¹å™¨ï¼ˆåˆå§‹éš±è—ï¼‰ */
      #customDateRange {
        display: none;
        align-items: center;
        gap: 6px;
        margin-left: 8px;
      }

      #customDateRange input[type="date"] {
        padding: 4px 6px;
        border-radius: 4px;
        border: 1px solid #ccc;
        font-size: 14px;
      }

      #customDateRange button {
        padding: 4px 8px;
        font-size: 14px;
        background-color: #2196f3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      #customDateRange button:hover {
        background-color: #1976d2;
      }
      h1,
      h2,
      h3 {
        color: #333;
      }

      .menu-container {
        position: absolute;
        top: 10px;
        right: 20px;
        font-size: 24px;
        z-index: 999;
      }

      .menu-icon {
        position: relative;
        cursor: pointer;
        user-select: none;
      }

      .dropdown {
        display: none;
        position: absolute;
        right: 0;
        top: 30px;
        background-color: #fff;
        box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
        border: 1px solid #ddd;
        border-radius: 4px;
        min-width: 120px;
      }

      .dropdown a {
        display: block;
        padding: 10px 15px;
        color: #333;
        text-decoration: none;
        font-size: 14px;
      }

      .dropdown a:hover {
        background-color: #f2f2f2;
      }

      .apexcharts-annotation-label.annotation-vertical {
        display: inline-block;
        transform-origin: center;
        transform: rotate(-90deg);
        line-height: 1;
      }
    </style>
  </head>
  <body>
    <div id="main-content">
      <h1>è‚¡ç¥¨åˆ†æå¹³å°</h1>
      <!-- åŠ ä¸€å€‹ã€Œä¸‰æ§“é¸å–®ã€ -->
      <div class="menu-container" id="menuContainer">
        <div class="menu-icon">
          â˜°
          <div class="dropdown" id="dropdownMenu">
            <div
              id="user-email"
              style="padding: 8px 15px; font-weight: bold"
            ></div>
            <a id="login-btn" href="login.html">ç™»å…¥</a>
            <a id="register-btn" href="register.html">è¨»å†Š</a>
            <a id="logout-btn" href="#" onclick="logout()" style="display: none"
              >ç™»å‡º</a
            >
          </div>
        </div>
      </div>

      <div class="search-container">
        <input
          type="text"
          id="symbolInput"
          placeholder="è¼¸å…¥è‚¡ç¥¨ä»£è™Ÿæˆ–åç¨±"
          autocomplete="off"
        />
        <div id="suggestions"></div>
      </div>

      <div>
        <h2
          id="chartTitle"
          style="text-align: left; font-weight: bold; margin: 0; padding: 0"
        ></h2>
        <div
          id="ohlcInfo"
          style="text-align: left; font-size: 16px; padding: 15px 0"
        ></div>
        <div class="time-range-bar">
          <div class="time-range-item" onclick="setActive(this, '5d')">5å¤©</div>
          <div class="time-range-item" onclick="setActive(this, '1m')">1æœˆ</div>
          <div class="time-range-item" onclick="setActive(this, '3m')">3æœˆ</div>
          <div class="time-range-item" onclick="setActive(this, '6m')">6æœˆ</div>
          <div class="time-range-item" onclick="setActive(this, 'ytd')">
            YTD
          </div>
          <div class="time-range-item" onclick="setActive(this, '1y')">1å¹´</div>
          <div class="time-range-item" onclick="setActive(this, '3y')">3å¹´</div>

          <!-- æ—¥æ›†æŒ‰éˆ•èˆ‡è‡ªè¨‚æ™‚é–“å®¹å™¨ -->
          <div class="calendar-btn" onclick="toggleCustomDate()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <path
                d="M19 4h-1V2h-2v2H8V2H6v2H5C3.9 4 3 4.9 3 6v14c0 
      1.1.9 2 2 2h14c1.1 0 2-.9 
      2-2V6c0-1.1-.9-2-2-2zm0 
      16H5V9h14v11z"
              />
            </svg>
          </div>
          <div id="customDateRange">
            èµ·ï¼š<input type="date" id="customStart" /> è¿„ï¼š<input
              type="date"
              id="customEnd"
            />
            <button onclick="loadStockWithRange(getSymbol(), 'custom')">
              æŸ¥è©¢
            </button>
          </div>
          <label class="show-periods">
            <input
              type="checkbox"
              id="togglePeriods"
              onchange="togglePeriods()"
            />
            é¡¯ç¤ºæ™‚é–“å€éš”
          </label>
        </div>
        <div id="chart"></div>
      </div>
    </div>

    <div
      id="main-chart-row"
      style="display: flex; align-items: stretch; min-height: 500px"
    >
      <!-- å³å´åŠŸèƒ½ï¼ˆèˆ‡åœ–è¡¨ç­‰é«˜ï¼‰ -->
      <div
        style="
          margin-left: 10px;
          display: flex;
          flex-direction: column;
          margin-top: 250px;
        "
      >
        <div style="flex: 1; display: flex">
          <!-- æŠ€è¡“æŒ‡æ¨™æ§åˆ¶ -->
          <div style="width: 140px; flex: 1; padding: 5px">
            <h3 style="margin-top: 0">é¡¯ç¤ºæŠ€è¡“ç·š</h3>
            <div class="checkbox-group">
              <label
                ><input type="checkbox" class="indicator-check" value="Sma 5" />
                SMA 5</label
              >
              <label
                ><input
                  type="checkbox"
                  class="indicator-check"
                  value="Sma 10"
                />
                SMA 10</label
              >
              <label
                ><input
                  type="checkbox"
                  class="indicator-check"
                  value="Sma 20"
                />
                SMA 20</label
              >
              <label
                ><input
                  type="checkbox"
                  class="indicator-check"
                  value="Sma 60"
                />
                SMA 60</label
              >
              <label
                ><input
                  type="checkbox"
                  class="indicator-check"
                  value="Sma 120"
                />
                SMA 120</label
              >
              <label
                ><input
                  type="checkbox"
                  class="indicator-check"
                  value="Sma 240"
                />
                SMA 240</label
              >
              <label
                ><input type="checkbox" class="indicator-check" value="DIF" />
                DIF (å¿«ç·š)
              </label>
              <label
                ><input type="checkbox" class="indicator-check" value="DEA" />
                DEA (æ…¢ç·š)
              </label>
              <label
                ><input type="checkbox" class="indicator-check" value="K" />
                K</label
              >
              <label
                ><input type="checkbox" class="indicator-check" value="D" />
                D</label
              >
              <label
                ><input type="checkbox" class="indicator-check" value="J" />
                J</label
              >
              <label
                ><input type="checkbox" class="indicator-check" value="Bias" />
                Bias</label
              >
            </div>
          </div>

          <!-- æ¢ä»¶åˆ¤æ–·å€ -->
          <div style="width: 170px; flex: 1.5; padding: 5px">
            <h3 style="margin-top: 0">æ¢ä»¶åˆ¤æ–·</h3>
            <div class="checkbox-group">
              <label
                ><input type="checkbox" class="rule-check" value="sma-cross" />
                SMA 5 > SMA 20</label
              >
              <label>
                <input type="checkbox" class="rule-check" value="three-red" />
                é€£çºŒä¸‰å¤©ç´…æŸ±
              </label>
              <label>
                <input
                  type="checkbox"
                  class="rule-check"
                  value="three-down-volume"
                />
                æˆäº¤é‡é€£é™ä¸‰å¤©
              </label>
              <label
                ><input
                  type="checkbox"
                  class="rule-check"
                  value="dif-above-dea"
                />
                MACDï¼šDIFçªç ´DEA</label
              >
              <label
                ><input
                  type="checkbox"
                  class="rule-check"
                  value="dea-below-dif"
                />
                MACDï¼šDEAè·Œç ´DIF</label
              >
              <label
                ><input type="checkbox" class="rule-check" value="kd-cross" />
                Kä¸Šç©¿D ä¸” K<20</label
              >
              <label
                ><input type="checkbox" class="rule-check" value="bias-high" />
                Bias > 5</label
              >
              <label
                ><input type="checkbox" class="rule-check" value="bias-low" />
                Bias < -5</label
              >
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const SUPABASE_URL = "https://sbzzfjlmhvuchzwqllgf.supabase.co";
      const SUPABASE_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNienpmamxtaHZ1Y2h6d3FsbGdmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI3NDE2OTQsImV4cCI6MjA2ODMxNzY5NH0.fvDVLvGLQdMRuCMXmja8ltpXC3TcjZxq78xbnt9Bh-U";

      const client = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

      const menuContainer = document.getElementById("menuContainer");
      const dropdownMenu = document.getElementById("dropdownMenu");

      // è¨»å†Šé»æ“Šé€£çµ
      async function handleRedirect() {
        const hash = window.location.hash;
        if (hash && hash.includes("access_token")) {
          const { data, error } = await client.auth.getSessionFromUrl({
            storeSession: true,
          });
          if (error) {
            console.error("è™•ç† redirect ç™»å…¥å¤±æ•—:", error.message);
            return;
          }
          console.log("ç™»å…¥æˆåŠŸï¼Œä½¿ç”¨è€…è³‡è¨Šï¼š", data.session?.user);

          // å¯å°å‘åˆ°ä¸»ç•«é¢æˆ–æ¸…é™¤ URL ä¸­çš„ token
          window.history.replaceState(
            {},
            document.title,
            window.location.pathname
          );
        }
      }
      handleRedirect();

      // æ»‘é¼ ç§»å…¥é¡¯ç¤ºé¸å–®
      menuContainer.addEventListener("mouseenter", () => {
        dropdownMenu.style.display = "block";
      });

      // æ»‘é¼ ç§»å‡ºæ•´å€‹å®¹å™¨éš±è—é¸å–®
      menuContainer.addEventListener("mouseleave", () => {
        dropdownMenu.style.display = "none";
      });

      // ç™»å‡º
      async function logout() {
        const { error } = await client.auth.signOut();
        if (!error) {
          alert("å·²ç™»å‡º");
          checkLoginStatus();
          hideMenu();
        }
      }

      // åˆ¤æ–·ç™»å…¥ç‹€æ…‹
      async function checkLoginStatus() {
        const {
          data: { user },
        } = await client.auth.getUser();

        const emailSpan = document.getElementById("user-email");
        const loginBtn = document.getElementById("login-btn");
        const registerBtn = document.getElementById("register-btn");
        const logoutBtn = document.getElementById("logout-btn");

        if (user) {
          emailSpan.textContent = user.email;
          emailSpan.style.display = "block";
          loginBtn.style.display = "none";
          registerBtn.style.display = "none";
          logoutBtn.style.display = "block";
        } else {
          emailSpan.textContent = "";
          emailSpan.style.display = "none";
          loginBtn.style.display = "block";
          registerBtn.style.display = "block";
          logoutBtn.style.display = "none";
        }
      }

      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const accessToken = hashParams.get("access_token");
      const refreshToken = hashParams.get("refresh_token");

      if (accessToken && refreshToken) {
        supabase.auth
          .setSession({
            access_token: accessToken,
            refresh_token: refreshToken,
          })
          .then(() => {
            // æˆåŠŸç™»å…¥ï¼Œè·³è½‰æˆ–é¡¯ç¤ºç™»å…¥ç‹€æ…‹
            window.location.hash = ""; // æ¸…æ‰ URL hash
            alert("ç™»å…¥æˆåŠŸ");
          });
      }
      window.onload = checkLoginStatus;

      let chart;
      let originalMinX = null;
      let originalMaxX = null;

      //ä¿æŒé¡¯ç¤ºæŠ€è¡“ç·š
      //å„²å­˜ç›®å‰å‹¾é¸çš„å‡½å¼
      function getCheckedIndicators() {
        return Array.from(
          document.querySelectorAll(".indicator-check:checked")
        ).map((el) => el.value);
      }

      //é‚„åŸå‹¾é¸å‡½å¼
      function restoreCheckedIndicators(checkedIndicators) {
        document.querySelectorAll(".indicator-check").forEach((el) => {
          el.checked = checkedIndicators.includes(el.value);
        });
      }

      //å¥—ç”¨å‹¾é¸çš„ç·šåˆ°åœ–è¡¨
      function applyIndicators() {
        document.querySelectorAll(".indicator-check").forEach((checkbox) => {
          checkbox.onchange(); // è§¸ç™¼ onchange æ›´æ–°ç·š
        });
      }

      //ä¿æŒæ¢ä»¶åˆ¤æ–·é¸æ“‡
      //å„²å­˜æ¢ä»¶åˆ¤æ–·å‹¾é¸ç‹€æ…‹
      function getCheckedRules() {
        return Array.from(document.querySelectorAll(".rule-check:checked")).map(
          (el) => el.value
        );
      }

      //é‚„åŸæ¢ä»¶åˆ¤æ–·å‹¾é¸ç‹€æ…‹
      function restoreCheckedRules(checkedRules) {
        document.querySelectorAll(".rule-check").forEach((el) => {
          el.checked = checkedRules.includes(el.value);
        });
      }

      //å¥—ç”¨å‹¾é¸çš„æ¢ä»¶åˆ¤æ–·åˆ°åœ–è¡¨
      function applyRules() {
        document.querySelectorAll(".rule-check").forEach((checkbox) => {
          checkbox.onchange(); // è§¸ç™¼ onchange æ›´æ–°åœ–è¡¨æ¨™è¨»
        });
      }

      const allIndicators = [
        "Sma 5",
        "Sma 10",
        "Sma 20",
        "Sma 60",
        "Sma 120",
        "Sma 240",
        "DIF",
        "DEA",
        "K",
        "D",
        "J",
        "Bias",
      ];

      function getSymbol() {
        return document.getElementById("symbolInput").value || "AAPL";
      }

      function selectSymbol(symbol) {
        document.getElementById("symbolInput").value = symbol;
        document.getElementById("suggestions").style.display = "none";
        loadStockWithRange(symbol, "3m"); // Default to 1 year on new selection
      }

      async function loadStockWithRange(symbol, range) {
        const checkedIndicatorsBefore = getCheckedIndicators(); // æŠ€è¡“ç·š
        const checkedRulesBefore = getCheckedRules(); // æ¢ä»¶åˆ¤æ–·

        const rangeToCount = {
          "5d": 5,
          "1m": 22,
          "3m": 66,
          "6m": 132,
          "1y": 264,
          "3y": 792,
        };
        let count = rangeToCount[range] || 264;

        // YTD calculation
        if (range === "ytd") {
          const today = new Date();
          const startOfYear = new Date(today.getFullYear(), 0, 1);
          const diffTime = Math.abs(today - startOfYear);
          count = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        }

        const { data, error } = await client
          .from("stocks")
          .select(
            'date, symbol, open, high, low, close, volume, "Sma 5", "Sma 10", "Sma 20", "Sma 60", "Sma 120", "Sma 240", "DIF", "DEA", K, D, J, Bias'
          )
          .eq("symbol", symbol)
          .order("date", { ascending: false })
          .limit(count);

        if (error || !data || data.length === 0) return alert("æŸ¥ç„¡è³‡æ–™");
        const sortedData = data.sort(
          (a, b) => new Date(a.date) - new Date(b.date)
        );

        displayStockData(sortedData, symbol);

        // é‚„åŸç‹€æ…‹
        restoreCheckedIndicators(checkedIndicatorsBefore);
        applyIndicators();

        restoreCheckedRules(checkedRulesBefore);
        applyRules();

        console.log("symbol:", symbol, "count:", count);
        console.log("error:", error);
        console.log("data:", data);
        await fetchStockData(symbol, range);
      }

      function displayStockData(data, symbol) {
        window.stockData = data;

        // const tradingDates = data.map(...)
        window.tradingDates = data.map((row) => {
          const date = new Date(row.date);
          return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(
            2,
            "0"
          )}-${String(date.getDate()).padStart(2, "0")}`;
        });

        // é å…ˆè¨ˆç®—è¦åœ¨å“ªäº› category é¡¯ç¤ºå¹´ä»½
        const showYearSet = new Set();
        for (let i = 0; i < tradingDates.length; i++) {
          const year = tradingDates[i].split("-")[0];
          const prevYear = i > 0 ? tradingDates[i - 1].split("-")[0] : null;
          if (i === 0 || year !== prevYear) {
            showYearSet.add(tradingDates[i]); // ç”¨ category å€¼ç•¶ keyï¼ˆ"YYYY-MM-DD"ï¼‰
          }
        }

        const chartData = data.map((row, idx) => ({
          x: row.date,
          y: [
            parseFloat(row.open),
            parseFloat(row.high),
            parseFloat(row.low),
            parseFloat(row.close),
          ],
        }));

        const volumeData = data.map((row, idx) => ({
          x: row.date,
          y: parseFloat(row.volume),
        }));

        // ---- æˆäº¤é‡ y è»¸çš„å‹•æ…‹ä¸Šä¸‹ç•Œï¼ˆå¯èª¿å£“ç¸®æ¯”ä¾‹ï¼‰----
        const volMax = Math.max(...volumeData.map((p) => p.y));
        const volMin = Math.min(...volumeData.map((p) => p.y));

        // æƒ³ã€Œå£“ç¸®ã€æŸ±å­ï¼ˆçœ‹èµ·ä¾†æ›´çŸ®ï¼‰â†’ æŠŠé€™å€‹æ¯”ä¾‹èª¿å¤§ï¼Œ0.30 ~ 0.60éƒ½å¯
        const volPadTopRatio = 1.8; // 40% ç©ºé–“ï¼ŒæŸ±å­æœƒæ˜é¡¯çŸ®ä¸€äº›
        const volYMax = volMax + volMax * volPadTopRatio;

        // é€šå¸¸æŠŠä¸‹ç•Œé– 0 å°±å¥½ï¼›è‹¥æƒ³æ•´é«”å¾€ä¸Šé£„ï¼Œå¯æ”¹æˆè² å€¼ï¼ˆå¦‚ -volMax*0.1ï¼‰
        const volYMin = 0;

        const prices = data.flatMap((r) => [
          parseFloat(r.high),
          parseFloat(r.low),
        ]);

        const dataMin = Math.min(...prices);
        const dataMax = Math.max(...prices);
        const range = dataMax - dataMin;
        // æƒ³è®“ K æ£’æ›´é ä¸Š â†’ èª¿å¤§ padBottomï¼›ä¸è¦å¤ªå£“ç¸® â†’ padTop å°ä¸€é»
        const padBottom = range * 0.55; // ä¸‹æ–¹å¤šç•™ 35% ç©ºé–“ï¼ˆå¯èª¿ï¼‰
        const padTop = range * 0.05; // ä¸Šæ–¹ç•™ 5% ç©ºé–“ï¼ˆå¯èª¿ï¼‰

        const yMin = Math.max(0, dataMin - padBottom);
        const yMax = dataMax + padTop;

        // æ¨™é¡Œ
        document.getElementById("chartTitle").innerText = `${symbol}`;
        document.getElementById("ohlcInfo").innerHTML =
          "å°‡æ»‘é¼ æ‡¸åœåœ¨åœ–è¡¨ä¸Šä»¥æŸ¥çœ‹è©³ç´°è³‡è¨Š";

        //const minY = Math.min(...prices) * 0.3;
        // const maxY = Math.max(...prices) * 1.05;

        if (chart) chart.destroy();

        const options = {
          chart: {
            type: "candlestick",
            height: 500,
            zoom: { enabled: true },
            events: {
              zoomed: function (chartContext, { xaxis }) {
                if (window.currentMonths) {
                  addPeriodSeparators(window.currentMonths);
                }
              },
              scrolled: function (chartContext, { xaxis }) {
                if (window.currentMonths) {
                  addPeriodSeparators(window.currentMonths);
                }
              },
            },
          },
          legend: {
            show: false,
          },

          plotOptions: {
            candlestick: {
              colors: {
                upward: "#e74c3c", // ğŸ”º æ¼² â†’ ç´…è‰²
                downward: "#2ecc71", // ğŸ”» è·Œ â†’ ç¶ è‰²
              },
            },
            bar: {
              columnWidth: "70%",
            },
          },
          states: {
            hover: {
              filter: {
                type: "darken", // ğŸ”‘ æ”¹æˆè®Šæ·±è‰²
                value: 0.7, // è¶Šå°è¶Šæ·± (0.5 å¾ˆæ˜é¡¯)
              },
            },
            active: {
              filter: {
                type: "darken",
                value: 1.5,
              },
            },
          },
          xaxis: {
            type: "category",
            categories: tradingDates,
            tickAmount: 20,
            labels: {
              rotate: -45,
              formatter: (v) => {
                if (!v) return "";
                if (showYearSet.has(v)) {
                  return v.split("-")[0]; // é¡¯ç¤ºå¹´ä»½
                }
                const [, month, day] = v.split("-");
                return `${parseInt(month, 10)}/${parseInt(day, 10)}`;
              },
            },
            tooltip: {
              enabled: false, // ğŸ”‘ é—œé–‰åº•éƒ¨å°æ¡†æ¡†
            },
          },

          yaxis: [
            {
              title: { text: "åƒ¹æ ¼ / SMA " },
              min: yMin,
              max: yMax,
              labels: { formatter: (val) => Number(val.toFixed(2)) },
              opposite: false, //  ä¸»åƒ¹æ ¼è»¸åœ¨å·¦
            },
            {
              title: { text: "Volume" },
              min: volYMin,
              max: volYMax,
              labels: {
                formatter: function (val) {
                  if (val >= 1_000_000_000) {
                    return (val / 1_000_000_000).toFixed(0) + "B"; // åå„„
                  } else if (val >= 1_000_000) {
                    return (val / 1_000_000).toFixed(0) + "M"; // ç™¾è¬
                  } else if (val >= 1_000) {
                    return (val / 1_000).toFixed(0) + "K"; // åƒ
                  }
                  return val.toFixed(0);
                },
              },
              /*å¦‚æœå°è‚¡åŠ é€²ä¾†å‰ï¼Œç”¨currentSymbol.endsWith(".TW");äº‹å…ˆè¨»è¨˜ï¼Œå¹³å°å¯æ ¹æ“šå°è‚¡/ç¾è‚¡è®Šå‹•å–®ä½
                      labels: {
                        formatter: function (val) {
                          const isTW = currentSymbol.endsWith(".TW"); // åˆ¤æ–·å°è‚¡
                          if (isTW) {
                            if (val >= 1_000_000) return (val / 1_000_000).toFixed(2) + "Må¼µ";
                            if (val >= 1_000) return (val / 1_000).toFixed(2) + "Kå¼µ";
                            return val.toFixed(0) + "å¼µ";
                          } else {
                            if (val >= 1_000_000_000) return (val / 1_000_000_000).toFixed(2) + "B";
                            if (val >= 1_000_000) return (val / 1_000_000).toFixed(2) + "M";
                            if (val >= 1_000) return (val / 1_000).toFixed(2) + "K";
                            return val.toFixed(0);
                          }
                        },
                      }
                    */

              opposite: true, // ğŸ”‘ æˆäº¤é‡æ°¸é åœ¨å³
              show: true,
            },
            {
              title: { text: "MACD / KDJ " },
              show: false,
              tickAmount: 5,
              labels: { formatter: (val) => Number(val.toFixed(2)) },
              opposite: false, // ğŸ”‘ å‹•é‡è»¸ä¹Ÿåœ¨å·¦
            },
          ],

          series: [
            { name: "Kç·šåœ–", type: "candlestick", data: chartData },
            {
              name: "æˆäº¤é‡",
              type: "bar",
              data: volumeData,
              yAxisIndex: 1,
              color: "#A7B3DB", // ç´…ç¢§BENIMIDORI (è—),
            },
          ],
          tooltip: {
            shared: true,
            custom: function ({ series, dataPointIndex, w }) {
              const ohlc = w.globals.initialSeries[0].data[dataPointIndex].y;
              const date = tradingDates[dataPointIndex];

              // åˆ¤æ–·æ”¶ç›¤åƒ¹æ¼²è·Œï¼Œæ±ºå®šé¡è‰²
              const closeColor = ohlc[3] > ohlc[0] ? "#e74c3c" : "#2ecc71";

              // å–å¾—æˆäº¤é‡
              const volume = w.globals.initialSeries[1].data[dataPointIndex].y;

              // è½‰æ›æˆäº¤é‡å–®ä½
              function formatVolume(val) {
                if (val >= 1e6) return (val / 1e6).toFixed(2) + "M";
                if (val >= 1e3) return (val / 1e3).toFixed(2) + "K";
                return val.toString();
              }
              const volumeFormatted = formatVolume(volume);

              // âœ… æŠ€è¡“ç·šæ•¸å€¼ï¼ˆåªé¡¯ç¤ºå·²å‹¾é¸çš„ï¼‰
              let techLinesHtml = "";
              const checked = getCheckedIndicators();
              checked.forEach((name) => {
                const idx = w.globals.seriesNames.indexOf(name);
                if (idx >= 0) {
                  const val = series[idx][dataPointIndex];
                  if (val != null) {
                    techLinesHtml += `<div style="color:${
                      indicatorColors[name]
                    };">
                                ${name}: ${val.toFixed(2)}
                              </div>`;
                  }
                }
              });

              document.getElementById("ohlcInfo").innerHTML =
                `æ—¥æœŸ: ${date}ã€€` +
                `<span style="color:black;">é–‹ : </span><span style="color:${closeColor};">${ohlc[0].toFixed(
                  2
                )}</span> ` +
                `<span style="color:black;">é«˜ : </span><span style="color:${closeColor};">${ohlc[1].toFixed(
                  2
                )}</span> ` +
                `<span style="color:black;">ä½ : </span><span style="color:${closeColor};">${ohlc[2].toFixed(
                  2
                )}</span> ` +
                `<span style="color:black;">æ”¶ : </span><span style="color:${closeColor};">${ohlc[3].toFixed(
                  2
                )}</span>`;

              return `
                          <div style="background:rgba(255,255,255,0.85); padding:8px; border-radius:6px; font-size:13px;">
                            <div style="font-weight:bold; margin-bottom:4px;">${date}</div>
                            <div style="color:#555;">æˆäº¤é‡: ${volumeFormatted}</div>
                            ${techLinesHtml}
                          </div>`;
            },
          },
        };

        chart = new ApexCharts(document.querySelector("#chart"), options);
        chart.render();

        const indicatorFieldMap = {
          "Sma 5": "Sma 5",
          "Sma 10": "Sma 10",
          "Sma 20": "Sma 20",
          "Sma 60": "Sma 60",
          "Sma 120": "Sma 120",
          "Sma 240": "Sma 240",
          DIF: "DIF",
          DEA: "DEA",
          K: "K",
          D: "D",
          J: "J",
          Bias: "Bias",
        };

        const indicatorGroups = {
          price: ["Sma 5", "Sma 10", "Sma 20", "Sma 60", "Sma 120", "Sma 240"],
          momentum: ["Bias", "DIF", "DEA", "K", "D", "J"],
        };

        document.querySelectorAll(".indicator-check").forEach((checkbox) => {
          checkbox.onchange = () => {
            const checked = Array.from(
              document.querySelectorAll(".indicator-check:checked")
            ).map((cb) => cb.value);

            // ğŸ”‘ æ°¸é ä¿ç•™ Kç·š + æˆäº¤é‡
            let newSeries = [
              { name: "Kç·šåœ–", type: "candlestick", data: chartData },
              {
                name: "æˆäº¤é‡",
                type: "bar",
                data: volumeData,
                yAxisIndex: 1,
                color: "#A7B3DB", // ç´…ç¢§BENIMIDORI (è—)
              },
            ];

            // å¦‚æœæ²’å‹¾ â†’ åªé¡¯ç¤º Kç·š+æˆäº¤é‡
            if (checked.length === 0) {
              chart.updateOptions({
                series: newSeries,
                yaxis: [
                  { ...chart.w.config.yaxis[0], show: true },
                  { ...chart.w.config.yaxis[1], show: true },
                  { ...chart.w.config.yaxis[2], show: false },
                ],
              });
              return;
            }

            let momentumSelected = false;

            checked.forEach((name) => {
              const field = indicatorFieldMap[name];
              if (!field) return;
              const dataSeries = data.map((row, idx) => ({
                x: row.date,
                y: row[field] != null ? parseFloat(row[field]) : null,
              }));

              let yAxisIndex = 0;
              if (indicatorGroups.momentum.includes(name)) {
                yAxisIndex = 2;
                momentumSelected = true;
              }

              newSeries.push({
                name,
                type: "line",
                data: dataSeries,
                yAxisIndex,
                color: indicatorColors[name] || "#000", // é è¨­é»‘è‰²
              });
            });

          chart.updateOptions({
            series: newSeries,
            yaxis: [
              { ...chart.w.config.yaxis[0], show: true },
              { ...chart.w.config.yaxis[1], show: true }, // ğŸ”‘ æˆäº¤é‡æ°¸é é¡¯ç¤º
              { ...chart.w.config.yaxis[2], show: momentumSelected },
            ],
          });
        };

          // --- å…±ç”¨çš„ hover è™•ç† ---
          const label = checkbox.parentElement;

          // å…±ç”¨ hover è™•ç†ï¼šåªæ”¹ç·šæ¢ç²—ç´°ï¼Œä¸æ”¹æ–‡å­—æ¨£å¼
          function handleHover(isEnter) {
            const name = checkbox.value;
            const idx = chart.w.globals.seriesNames.indexOf(name);

            if (idx >= 0) {
              const widths = chart.w.config.series.map((s, i) => {
                if (s.type === "line") {
                  // hover æ™‚æŠŠå°æ‡‰é‚£æ¢ line åŠ ç²—ï¼Œå…¶é¤˜ line ä¿æŒ 2ï¼Œé line(è Ÿç‡­/é‡) = 1
                  return isEnter && i === idx ? 3 : 2;
                }
                return 1;
              });

              chart.updateOptions({ stroke: { width: widths } });
            }
          }

          // ç¶å®šåœ¨ checkbox èˆ‡ labelï¼ˆæ–‡å­—ä¹Ÿæœƒè§¸ç™¼ï¼Œä½†æ–‡å­—æœ¬èº«ä¸æ”¹è®Šï¼‰
          checkbox.addEventListener("mouseenter", () => handleHover(true));
          checkbox.addEventListener("mouseleave", () => handleHover(false));
          label.addEventListener("mouseenter", () => handleHover(true));
          label.addEventListener("mouseleave", () => handleHover(false));

          // å°å„ªåŒ–ï¼šè®“æ•´å€‹ label é¡¯ç¤ºå¯é»æ“Šæ¸¸æ¨™ï¼ˆä¸æœƒæ”¹å­—é«”ï¼‰
          label.style.cursor = "pointer";
        });
        // é¡¯ç¤ºåœ–è¡¨å¾Œ
        // åœ–è¡¨ç”Ÿæˆå¾Œ
        restoreCheckedIndicators(getCheckedIndicators());
        applyIndicators();

        restoreCheckedRules(getCheckedRules());
        applyRules(); // ç«‹å³å¥—ç”¨å·²å‹¾é¸çš„ç·š

        if (showPeriods) {
          addPeriodSeparators(currentMonths);
        }
      }

      function updateVolRatio(value) {
        VOL_PAD_TOP_RATIO = parseFloat(value);
        document.getElementById("volRatioValue").textContent = value;
        if (chart) {
          // é‡æ–°ç¹ªåœ–ï¼šé‡æ–°è¼‰å…¥æˆ–æ›´æ–°æˆäº¤é‡çš„ y è»¸
          const volMax = Math.max(
            ...chart.w.globals.initialSeries[1].data.map((d) => d.y)
          );
          const volYMax = volMax + volMax * VOL_PAD_TOP_RATIO;
          chart.updateOptions({
            yaxis: [
              chart.w.config.yaxis[0],
              {
                ...chart.w.config.yaxis[1],
                max: volYMax,
                min: 0,
              },
              chart.w.config.yaxis[2],
            ],
          });
        }
      }

      function highlightConditions(rules) {
  if (!window.stockData || window.stockData.length === 0 || !chart) return;

  // === å»ºç«‹æ¢ä»¶æ¨™è¨»é» ===
  function makePoint(dateStr, y, text) {
    return {
      x: dateStr,                // âœ… ç”¨æ—¥æœŸå­—ä¸²ï¼Œå’Œ series å®Œå…¨ä¸€è‡´
      y: y,
      marker: {
        size: 5,                 // âœ… å…ˆç¢ºä¿å¯è¦‹
        fillColor: "#000000",
        strokeColor: "#000000",
        strokeWidth: 1,
        // shape: "triangle",    // âš  å…ˆæ‹¿æ‰é¿å…å½¢ç‹€ä¸æ”¯æ´å°è‡´ä¸é¡¯ç¤º
      },
      label: {
        borderColor: "transparent",
        offsetY: 30,
        style: {
          background: "transparent",
          color: "#000000",
          fontSize: "12px",
          fontWeight: "bold",
        },
        text: text,
        cssClass: "highlight-marker"
      },
    };
  }

  let annotations = [];

  if (rules.length === 0) {
    // æ¸…æ‰æ¢ä»¶æ¨™è¨»ï¼Œä½†ä¿ç•™ period æ¨™è¨»
    const existing = chart.w.config.annotations || {};
    const preservedPeriod = (existing.points || []).filter(p =>
      (p.label?.cssClass || "").includes("period-label")
    );
    chart.updateOptions({ annotations: { xaxis: existing.xaxis || [], points: preservedPeriod } });
    return;
  }

  // è¨ˆç®—æ¢ä»¶
  for (let i = 0; i < window.stockData.length; i++) {
    const row = window.stockData[i];
    const prev = window.stockData[i - 1];
    const prev2 = window.stockData[i - 2];
    if (!prev || !prev2) continue;

    const sma5 = parseFloat(row["Sma 5"]);
    const sma20 = parseFloat(row["Sma 20"]);
    const prevSma5 = parseFloat(prev["Sma 5"]);
    const prevSma20 = parseFloat(prev["Sma 20"]);
    const macd = parseFloat(row["DIF"]);
    const macdSignal = parseFloat(row["DEA"]);
    const prevMacd = parseFloat(prev["DIF"]);
    const prevMacdSignal = parseFloat(prev["DEA"]);
    const k = parseFloat(row["K"]);
    const d = parseFloat(row["D"]);
    const prevK = parseFloat(prev["K"]);
    const prevD = parseFloat(prev["D"]);
    const bias = parseFloat(row["Bias"]);

    const labelMap = {
      "sma-cross": "SMAâ†‘",
      "dif-above-dea": "MACDâ†‘",
      "dea-below-dif": "MACDâ†“",
      "kd-cross": "KDâ†‘",
      "bias-high": "åé›¢â†‘",
      "bias-low": "åé›¢â†“",
      "three-red": "é€£",
      "three-down-volume": "é‡â†“",
    };

    const checks = {
      "sma-cross": () => prevSma5 < prevSma20 && sma5 >= sma20,
      "dif-above-dea": () => prevMacd < prevMacdSignal && macd >= macdSignal,
      "dea-below-dif": () => prevMacdSignal < prevMacd && macdSignal >= macd,
      "kd-cross": () => prevK < prevD && k >= d && k < 20,
      "bias-high": () => bias > 5,
      "bias-low": () => bias < -5,
      "three-red": () => [row, prev, prev2].every(r => parseFloat(r.close) > parseFloat(r.open)),
      "three-down-volume": () => row.volume < prev.volume && prev.volume < prev2.volume,
    };

    if (rules.length === 1) {
      const r = rules[0];
      if (checks[r]?.()) {
        annotations.push(makePoint(row.date, row.low * 0.98, labelMap[r]));
      }
    } else {
      const allPass = rules.every(r => checks[r]?.());
      if (allPass) {
        const text = rules.map(r => labelMap[r]).join("");
        annotations.push(makePoint(row.date, row.low * 0.98, text));
      }
    }
  }

  // å’Œ period åˆ†éš”å…±å­˜ï¼šä¿ç•™ period points / xaxis
  const existing = chart.w.config.annotations || {};
  const preservedPeriodPoints = (existing.points || []).filter(p =>
    (p.label?.cssClass || "").includes("period-label")
  );
  const preservedXaxis = (existing.xaxis || []);

  chart.updateOptions({
    annotations: {
      xaxis: preservedXaxis,
      points: [...preservedPeriodPoints, ...annotations],
    },
  });
}


      document.querySelectorAll(".rule-check").forEach((cb) => {
        cb.onchange = () => {
          const rules = Array.from(
            document.querySelectorAll(".rule-check:checked")
          ).map((c) => c.value);
          highlightConditions(rules);
        };
      });

      function toggleCustomDate() {
        const div = document.getElementById("customDateRange");
        if (div.style.display === "none" || div.style.display === "") {
          div.style.display = "block";
        } else {
          div.style.display = "none";
        }
      }

      // æ™‚é–“åŠŸèƒ½åˆ—
      function setActive(el, range) {
        document
          .querySelectorAll(".time-range-item")
          .forEach((item) => item.classList.remove("active"));
        el.classList.add("active");

        document.getElementById("customDateRange").style.display = "none";

        loadStockWithRange(getSymbol(), range).then(() => {
          let months = 3;
          if (range === "1m") months = 1;
          if (range === "3m") months = 3;
          if (range === "6m") months = 6;
          if (range === "1y") months = 12;
          if (range === "3y") months = 36;

          // è¨˜éŒ„ç•¶å‰çš„å€é–“ï¼ˆè®“ zoom/scroll æ™‚èƒ½é‡ç•«ï¼‰
          window.currentMonths = months;

          addPeriodSeparators(months);
        });
      }

      function toggleCustomDate() {
        const container = document.getElementById("customDateRange");
        const isHidden =
          container.style.display === "none" || container.style.display === "";
        // é¡¯ç¤ºæˆ–éš±è—
        container.style.display = isHidden ? "flex" : "none";
        // å–æ¶ˆå…¶ä»–æ™‚é–“æŒ‰éˆ•çš„é¸ä¸­ç‹€æ…‹
        document
          .querySelectorAll(".time-range-item")
          .forEach((item) => item.classList.remove("active"));
      }

      // ç•«åœ–?
      function makeAnnotation(time, label, color = "#FF4560") {
        return {
          x: new Date(time).getTime(),
          borderColor: color,
          label: {
            borderColor: color,
            style: {
              color: "#fff",
              background: color,
              fontSize: "12px",
              padding: "2px 4px",
            },
            text: label,
            orientation: "horizontal",
            offsetY: 20,
          },
        };
      }
      const symbolInput = document.getElementById("symbolInput");
      const suggestions = document.getElementById("suggestions");

      // è¼¸å…¥æ–‡å­—æ™‚ â†’ æ¨¡ç³Šæœå°‹
      symbolInput.addEventListener("input", async (e) => {
        const keyword = e.target.value.trim();
        if (!keyword) return; // ä¸è¼¸å…¥å°±ä¸è™•ç†ï¼Œç”± focus äº‹ä»¶è™•ç†

        const { data, error } = await client
          .from("stocks_meta")
          .select("symbol, name_en, name_zh, short_name_en, short_name_zh")
          .or(
            `symbol.ilike.%${keyword}%,` +
              `name_en.ilike.%${keyword}%,` +
              `name_zh.ilike.%${keyword}%,` +
              `short_name_en.ilike.%${keyword}%,` +
              `short_name_zh.ilike.%${keyword}%`
          )
          .limit(10);

        renderSuggestions(data, error);
      });

      // èšç„¦æ™‚ â†’ æŠ“é è¨­ 10 ç­†è‚¡ç¥¨
      symbolInput.addEventListener("focus", async () => {
        // ä¾‹å¦‚ç›´æ¥æŠ“å‰ 10 ç­† (å¯åŠ æ¢ä»¶å¦‚ç†±é–€è‚¡ç¥¨)
        const { data, error } = await client
          .from("stocks_meta")
          .select("symbol, name_en, name_zh, short_name_en, short_name_zh")
          .limit(10);

        renderSuggestions(data, error);
      });

      function renderSuggestions(data, error) {
        if (error || !data || data.length === 0) {
          suggestions.innerHTML = `<div style='padding:8px;'>ç„¡ç¬¦åˆè‚¡ç¥¨</div>`;
          suggestions.style.display = "block";
          return;
        }

        suggestions.innerHTML = data
          .map((item) => {
            const nameDisplay =
              item.name_zh ||
              item.name_en ||
              item.short_name_zh ||
              item.short_name_en ||
              "";
            return `<div style='padding:8px; cursor:pointer' onclick='selectSymbol("${item.symbol}")'>
                ${item.symbol} - ${nameDisplay}
              </div>`;
          })
          .join("");
        suggestions.style.display = "block";
      }

      // Hide suggestions when clicking outside
      document.addEventListener("click", function (event) {
        const suggestionsDiv = document.getElementById("suggestions");
        const input = document.getElementById("symbolInput");
        if (!suggestionsDiv.contains(event.target) && event.target !== input) {
          suggestionsDiv.style.display = "none";
        }
      });

      document.addEventListener("DOMContentLoaded", () => {
        loadStockWithRange("AAPL", "3m"); // Load Apple stock for 1 year by default
      });

      // çµ±ä¸€é¡è‰²è¡¨
      const indicatorColors = {
        "Sma 5": "#e74c3c", // ç´…
        "Sma 10": "#3498db", // è—
        "Sma 20": "#27ae60", // ç¶ 
        "Sma 60": "#f39c12", // æ©˜
        "Sma 120": "#9b59b6", // ç´«
        "Sma 240": "#16a085", // é’
        DIF: "#d35400", // æ·±æ©˜
        DEA: "#8e44ad", // æ·±ç´«
        K: "#2ecc71", // æ·ºç¶ 
        D: "#2980b9", // æ·±è—
        J: "#c0392b", // æš—ç´…
        Bias: "#7f8c8d", // ç°
      };

      // åˆå§‹åŒ–æ™‚ï¼Œè®“ checkbox label æ–‡å­—é¡è‰²ä¸€è‡´
      document.querySelectorAll(".indicator-check").forEach((cb) => {
        const color = indicatorColors[cb.value];
        if (color) {
          cb.parentElement.style.color = color;
          cb.dataset.color = color; // å„²å­˜é¡è‰²ä»¥ä¾¿å¾ŒçºŒä½¿ç”¨
        }
      });

      // === åŠƒåˆ†å€é–“ + åŠ ä¸Šæ¨™è¨» ===
      function addPeriodSeparators(periodMonths) {
        if (!window.tradingDates || window.tradingDates.length === 0) return;
        if (!chart || !chart.w) return;

        // 1å€‹æœˆ â†’ ä¸ç•«å€éš”
        if (periodMonths === 1) {
          chart.updateOptions({
            annotations: {
              xaxis: [],
              points: chart.w.config.annotations.points || [],
            },
          });
          return;
        }

        const startDate = new Date(window.tradingDates[0]);
        const endDate = new Date(
          window.tradingDates[window.tradingDates.length - 1]
        );
        const totalMs = endDate - startDate;
        if (totalMs <= 0) return;

        let sections;
        let labels = [];

        if (periodMonths >= 12) {
          // å¹´åº¦ â†’ ç”¨å­£åº¦
          sections = 4;
          labels = ["Q1", "Q2", "Q3", "Q4"];
        } else {
          // å…¶ä»– â†’ æŒ‰æœˆä»½æ•¸é‡åˆ‡
          sections = periodMonths;
          labels = Array.from({ length: sections }, (_, i) =>
            (i + 1).toString()
          );
        }

        const interval = totalMs / sections;
        const xaxisAnnotations = [];
        const pointAnnotations = [];

        const yTop =
          (chart.w &&
            chart.w.config &&
            chart.w.config.yaxis &&
            chart.w.config.yaxis[0] &&
            chart.w.config.yaxis[0].max) ||
          null;

        for (let i = 0; i < sections; i++) {
          const sectionStart = new Date(startDate.getTime() + interval * i);
          const sectionEnd = new Date(startDate.getTime() + interval * (i + 1));
          const middle = new Date(
            (sectionStart.getTime() + sectionEnd.getTime()) / 2
          );

          let middleIndex = window.tradingDates.findIndex(
            (d) => new Date(d).getTime() >= middle.getTime()
          );
          if (middleIndex === -1) middleIndex = window.tradingDates.length - 1;

          // Q1/Q2... or æ•¸å­—
          pointAnnotations.push({
            x: middleIndex,
            y: yTop ? yTop * 0.98 : undefined,
            marker: { size: 0 },
            label: {
              borderColor: "transparent",
              style: {
                background: "transparent",
                color: "#000",
                fontSize: "14px",
                fontWeight: "bold",
                padding: "0",
              },
              text: labels[i] || (i + 1).toString(),
              cssClass: "annotation-vertical period-label",
            },
          });

          // åˆ†éš”ç·šï¼ˆæœ€å¾Œä¸€æ¢ä¸è¦ï¼‰
          if (i < sections - 1) {
            let lineIndex = window.tradingDates.findIndex(
              (d) => new Date(d).getTime() >= sectionEnd.getTime()
            );
            if (lineIndex !== -1 && lineIndex < window.tradingDates.length) {
              xaxisAnnotations.push({
                x: lineIndex,
                borderColor: "#999",
                strokeDashArray: 4,
                cssClass: "period-separator",
              });
            }
          }
        }

        const existing = chart.w.config.annotations || {};
        const existingXaxis = Array.isArray(existing.xaxis)
          ? existing.xaxis
          : [];
        const existingPoints = Array.isArray(existing.points)
          ? existing.points
          : [];

        // ä¿ç•™é period çš„ points
        const preservedPoints = existingPoints.filter((p) => {
          if (!p || !p.label) return true;
          const css = p.label.cssClass || "";
          return !css.includes("period-label");
        });

        // ä¿ç•™é period çš„ xaxis
        const preservedXaxis = existingXaxis.filter((x) => {
          const css = x.cssClass || "";
          return !css.includes("period-separator");
        });

        chart.clearAnnotations();
        pointAnnotations.forEach((p) => chart.addPointAnnotation(p));
        xaxisAnnotations.forEach((x) => chart.addXaxisAnnotation(x));
      }

      let currentMonths = 3; // ç´€éŒ„ç›®å‰é¸æ“‡çš„æœˆä»½
      let showPeriods = false; // æ˜¯å¦é¡¯ç¤ºæ™‚é–“å€éš”

      function togglePeriods() {
        showPeriods = document.getElementById("togglePeriods").checked;
        if (showPeriods) {
          addPeriodSeparators(currentMonths); // å‹¾é¸ â†’ ç•«å‡ºè™›ç·š
        } else {
          chart.clearAnnotations(); // å–æ¶ˆå‹¾é¸ â†’ ç§»é™¤è™›ç·š
        }
      }

      // === ç¶å®šæŒ‰éˆ•äº‹ä»¶ ===
      document.querySelectorAll(".time-range-item").forEach((btn) => {
        btn.addEventListener("click", () => {
          const range = btn.getAttribute("onclick").match(/'(.*?)'/)[1];
          let months = 3; // é è¨­å€¼
          if (range === "1m") months = 1;
          if (range === "3m") months = 3;
          if (range === "6m") months = 6;
          if (range === "1y") months = 12;
          if (range === "3y") months = 36;

          currentMonths = months; // æ›´æ–°ç‹€æ…‹

          // âš¡ï¸ æ¯æ¬¡æ›´æ›æ™‚é–“ â†’ æª¢æŸ¥æ˜¯å¦è¦é¡¯ç¤ºè™›ç·š
          if (showPeriods) {
            addPeriodSeparators(months);
          } else {
            chart.clearAnnotations();
          }
        });
      });
    </script>
  </body>
</html>
